// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schema.proto

#ifndef PROTOBUF_INCLUDED_schema_2eproto
#define PROTOBUF_INCLUDED_schema_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_schema_2eproto 

namespace protobuf_schema_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_schema_2eproto
namespace schema_proto {
class ArrowSchema;
class ArrowSchemaDefaultTypeInternal;
extern ArrowSchemaDefaultTypeInternal _ArrowSchema_default_instance_;
class DataType;
class DataTypeDefaultTypeInternal;
extern DataTypeDefaultTypeInternal _DataType_default_instance_;
class DictionaryType;
class DictionaryTypeDefaultTypeInternal;
extern DictionaryTypeDefaultTypeInternal _DictionaryType_default_instance_;
class Field;
class FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class FixedSizeBinaryType;
class FixedSizeBinaryTypeDefaultTypeInternal;
extern FixedSizeBinaryTypeDefaultTypeInternal _FixedSizeBinaryType_default_instance_;
class FixedSizeListType;
class FixedSizeListTypeDefaultTypeInternal;
extern FixedSizeListTypeDefaultTypeInternal _FixedSizeListType_default_instance_;
class KeyValueMetadata;
class KeyValueMetadataDefaultTypeInternal;
extern KeyValueMetadataDefaultTypeInternal _KeyValueMetadata_default_instance_;
class MapType;
class MapTypeDefaultTypeInternal;
extern MapTypeDefaultTypeInternal _MapType_default_instance_;
class Schema;
class SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class SchemaOptions;
class SchemaOptionsDefaultTypeInternal;
extern SchemaOptionsDefaultTypeInternal _SchemaOptions_default_instance_;
}  // namespace schema_proto
namespace google {
namespace protobuf {
template<> ::schema_proto::ArrowSchema* Arena::CreateMaybeMessage<::schema_proto::ArrowSchema>(Arena*);
template<> ::schema_proto::DataType* Arena::CreateMaybeMessage<::schema_proto::DataType>(Arena*);
template<> ::schema_proto::DictionaryType* Arena::CreateMaybeMessage<::schema_proto::DictionaryType>(Arena*);
template<> ::schema_proto::Field* Arena::CreateMaybeMessage<::schema_proto::Field>(Arena*);
template<> ::schema_proto::FixedSizeBinaryType* Arena::CreateMaybeMessage<::schema_proto::FixedSizeBinaryType>(Arena*);
template<> ::schema_proto::FixedSizeListType* Arena::CreateMaybeMessage<::schema_proto::FixedSizeListType>(Arena*);
template<> ::schema_proto::KeyValueMetadata* Arena::CreateMaybeMessage<::schema_proto::KeyValueMetadata>(Arena*);
template<> ::schema_proto::MapType* Arena::CreateMaybeMessage<::schema_proto::MapType>(Arena*);
template<> ::schema_proto::Schema* Arena::CreateMaybeMessage<::schema_proto::Schema>(Arena*);
template<> ::schema_proto::SchemaOptions* Arena::CreateMaybeMessage<::schema_proto::SchemaOptions>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace schema_proto {

enum LogicType {
  NA = 0,
  BOOL = 1,
  UINT8 = 2,
  INT8 = 3,
  UINT16 = 4,
  INT16 = 5,
  UINT32 = 6,
  INT32 = 7,
  UINT64 = 8,
  INT64 = 9,
  HALF_FLOAT = 10,
  FLOAT = 11,
  DOUBLE = 12,
  STRING = 13,
  BINARY = 14,
  FIXED_SIZE_BINARY = 15,
  LIST = 25,
  STRUCT = 26,
  DICTIONARY = 29,
  MAP = 30,
  FIXED_SIZE_LIST = 32,
  MAX_ID = 39,
  LogicType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LogicType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LogicType_IsValid(int value);
const LogicType LogicType_MIN = NA;
const LogicType LogicType_MAX = MAX_ID;
const int LogicType_ARRAYSIZE = LogicType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogicType_descriptor();
inline const ::std::string& LogicType_Name(LogicType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogicType_descriptor(), value);
}
inline bool LogicType_Parse(
    const ::std::string& name, LogicType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogicType>(
    LogicType_descriptor(), name, value);
}
enum Endianness {
  Little = 0,
  Big = 1,
  Endianness_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Endianness_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Endianness_IsValid(int value);
const Endianness Endianness_MIN = Little;
const Endianness Endianness_MAX = Big;
const int Endianness_ARRAYSIZE = Endianness_MAX + 1;

const ::google::protobuf::EnumDescriptor* Endianness_descriptor();
inline const ::std::string& Endianness_Name(Endianness value) {
  return ::google::protobuf::internal::NameOfEnum(
    Endianness_descriptor(), value);
}
inline bool Endianness_Parse(
    const ::std::string& name, Endianness* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Endianness>(
    Endianness_descriptor(), name, value);
}
// ===================================================================

class FixedSizeBinaryType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schema_proto.FixedSizeBinaryType) */ {
 public:
  FixedSizeBinaryType();
  virtual ~FixedSizeBinaryType();

  FixedSizeBinaryType(const FixedSizeBinaryType& from);

  inline FixedSizeBinaryType& operator=(const FixedSizeBinaryType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FixedSizeBinaryType(FixedSizeBinaryType&& from) noexcept
    : FixedSizeBinaryType() {
    *this = ::std::move(from);
  }

  inline FixedSizeBinaryType& operator=(FixedSizeBinaryType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FixedSizeBinaryType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FixedSizeBinaryType* internal_default_instance() {
    return reinterpret_cast<const FixedSizeBinaryType*>(
               &_FixedSizeBinaryType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(FixedSizeBinaryType* other);
  friend void swap(FixedSizeBinaryType& a, FixedSizeBinaryType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FixedSizeBinaryType* New() const final {
    return CreateMaybeMessage<FixedSizeBinaryType>(NULL);
  }

  FixedSizeBinaryType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FixedSizeBinaryType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FixedSizeBinaryType& from);
  void MergeFrom(const FixedSizeBinaryType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FixedSizeBinaryType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 byte_width = 1;
  void clear_byte_width();
  static const int kByteWidthFieldNumber = 1;
  ::google::protobuf::int32 byte_width() const;
  void set_byte_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:schema_proto.FixedSizeBinaryType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 byte_width_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FixedSizeListType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schema_proto.FixedSizeListType) */ {
 public:
  FixedSizeListType();
  virtual ~FixedSizeListType();

  FixedSizeListType(const FixedSizeListType& from);

  inline FixedSizeListType& operator=(const FixedSizeListType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FixedSizeListType(FixedSizeListType&& from) noexcept
    : FixedSizeListType() {
    *this = ::std::move(from);
  }

  inline FixedSizeListType& operator=(FixedSizeListType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FixedSizeListType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FixedSizeListType* internal_default_instance() {
    return reinterpret_cast<const FixedSizeListType*>(
               &_FixedSizeListType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FixedSizeListType* other);
  friend void swap(FixedSizeListType& a, FixedSizeListType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FixedSizeListType* New() const final {
    return CreateMaybeMessage<FixedSizeListType>(NULL);
  }

  FixedSizeListType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FixedSizeListType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FixedSizeListType& from);
  void MergeFrom(const FixedSizeListType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FixedSizeListType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 list_size = 1;
  void clear_list_size();
  static const int kListSizeFieldNumber = 1;
  ::google::protobuf::int32 list_size() const;
  void set_list_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:schema_proto.FixedSizeListType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 list_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DictionaryType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schema_proto.DictionaryType) */ {
 public:
  DictionaryType();
  virtual ~DictionaryType();

  DictionaryType(const DictionaryType& from);

  inline DictionaryType& operator=(const DictionaryType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DictionaryType(DictionaryType&& from) noexcept
    : DictionaryType() {
    *this = ::std::move(from);
  }

  inline DictionaryType& operator=(DictionaryType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DictionaryType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DictionaryType* internal_default_instance() {
    return reinterpret_cast<const DictionaryType*>(
               &_DictionaryType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DictionaryType* other);
  friend void swap(DictionaryType& a, DictionaryType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DictionaryType* New() const final {
    return CreateMaybeMessage<DictionaryType>(NULL);
  }

  DictionaryType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DictionaryType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DictionaryType& from);
  void MergeFrom(const DictionaryType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DictionaryType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schema_proto.DataType index_type = 1;
  bool has_index_type() const;
  void clear_index_type();
  static const int kIndexTypeFieldNumber = 1;
  private:
  const ::schema_proto::DataType& _internal_index_type() const;
  public:
  const ::schema_proto::DataType& index_type() const;
  ::schema_proto::DataType* release_index_type();
  ::schema_proto::DataType* mutable_index_type();
  void set_allocated_index_type(::schema_proto::DataType* index_type);

  // .schema_proto.DataType value_type = 2;
  bool has_value_type() const;
  void clear_value_type();
  static const int kValueTypeFieldNumber = 2;
  private:
  const ::schema_proto::DataType& _internal_value_type() const;
  public:
  const ::schema_proto::DataType& value_type() const;
  ::schema_proto::DataType* release_value_type();
  ::schema_proto::DataType* mutable_value_type();
  void set_allocated_value_type(::schema_proto::DataType* value_type);

  // bool ordered = 3;
  void clear_ordered();
  static const int kOrderedFieldNumber = 3;
  bool ordered() const;
  void set_ordered(bool value);

  // @@protoc_insertion_point(class_scope:schema_proto.DictionaryType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schema_proto::DataType* index_type_;
  ::schema_proto::DataType* value_type_;
  bool ordered_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schema_proto.MapType) */ {
 public:
  MapType();
  virtual ~MapType();

  MapType(const MapType& from);

  inline MapType& operator=(const MapType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapType(MapType&& from) noexcept
    : MapType() {
    *this = ::std::move(from);
  }

  inline MapType& operator=(MapType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapType* internal_default_instance() {
    return reinterpret_cast<const MapType*>(
               &_MapType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MapType* other);
  friend void swap(MapType& a, MapType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapType* New() const final {
    return CreateMaybeMessage<MapType>(NULL);
  }

  MapType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapType& from);
  void MergeFrom(const MapType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool keys_sorted = 1;
  void clear_keys_sorted();
  static const int kKeysSortedFieldNumber = 1;
  bool keys_sorted() const;
  void set_keys_sorted(bool value);

  // @@protoc_insertion_point(class_scope:schema_proto.MapType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool keys_sorted_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DataType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schema_proto.DataType) */ {
 public:
  DataType();
  virtual ~DataType();

  DataType(const DataType& from);

  inline DataType& operator=(const DataType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataType(DataType&& from) noexcept
    : DataType() {
    *this = ::std::move(from);
  }

  inline DataType& operator=(DataType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataType& default_instance();

  enum TypeRelatedValuesCase {
    kFixedSizeBinaryType = 1,
    kFixedSizeListType = 2,
    kDictionaryType = 3,
    kMapType = 4,
    TYPE_RELATED_VALUES_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataType* internal_default_instance() {
    return reinterpret_cast<const DataType*>(
               &_DataType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DataType* other);
  friend void swap(DataType& a, DataType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataType* New() const final {
    return CreateMaybeMessage<DataType>(NULL);
  }

  DataType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DataType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DataType& from);
  void MergeFrom(const DataType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .schema_proto.Field children = 101;
  int children_size() const;
  void clear_children();
  static const int kChildrenFieldNumber = 101;
  ::schema_proto::Field* mutable_children(int index);
  ::google::protobuf::RepeatedPtrField< ::schema_proto::Field >*
      mutable_children();
  const ::schema_proto::Field& children(int index) const;
  ::schema_proto::Field* add_children();
  const ::google::protobuf::RepeatedPtrField< ::schema_proto::Field >&
      children() const;

  // .schema_proto.LogicType logic_type = 100;
  void clear_logic_type();
  static const int kLogicTypeFieldNumber = 100;
  ::schema_proto::LogicType logic_type() const;
  void set_logic_type(::schema_proto::LogicType value);

  // .schema_proto.FixedSizeBinaryType fixed_size_binary_type = 1;
  bool has_fixed_size_binary_type() const;
  void clear_fixed_size_binary_type();
  static const int kFixedSizeBinaryTypeFieldNumber = 1;
  private:
  const ::schema_proto::FixedSizeBinaryType& _internal_fixed_size_binary_type() const;
  public:
  const ::schema_proto::FixedSizeBinaryType& fixed_size_binary_type() const;
  ::schema_proto::FixedSizeBinaryType* release_fixed_size_binary_type();
  ::schema_proto::FixedSizeBinaryType* mutable_fixed_size_binary_type();
  void set_allocated_fixed_size_binary_type(::schema_proto::FixedSizeBinaryType* fixed_size_binary_type);

  // .schema_proto.FixedSizeListType fixed_size_list_type = 2;
  bool has_fixed_size_list_type() const;
  void clear_fixed_size_list_type();
  static const int kFixedSizeListTypeFieldNumber = 2;
  private:
  const ::schema_proto::FixedSizeListType& _internal_fixed_size_list_type() const;
  public:
  const ::schema_proto::FixedSizeListType& fixed_size_list_type() const;
  ::schema_proto::FixedSizeListType* release_fixed_size_list_type();
  ::schema_proto::FixedSizeListType* mutable_fixed_size_list_type();
  void set_allocated_fixed_size_list_type(::schema_proto::FixedSizeListType* fixed_size_list_type);

  // .schema_proto.DictionaryType dictionary_type = 3;
  bool has_dictionary_type() const;
  void clear_dictionary_type();
  static const int kDictionaryTypeFieldNumber = 3;
  private:
  const ::schema_proto::DictionaryType& _internal_dictionary_type() const;
  public:
  const ::schema_proto::DictionaryType& dictionary_type() const;
  ::schema_proto::DictionaryType* release_dictionary_type();
  ::schema_proto::DictionaryType* mutable_dictionary_type();
  void set_allocated_dictionary_type(::schema_proto::DictionaryType* dictionary_type);

  // .schema_proto.MapType map_type = 4;
  bool has_map_type() const;
  void clear_map_type();
  static const int kMapTypeFieldNumber = 4;
  private:
  const ::schema_proto::MapType& _internal_map_type() const;
  public:
  const ::schema_proto::MapType& map_type() const;
  ::schema_proto::MapType* release_map_type();
  ::schema_proto::MapType* mutable_map_type();
  void set_allocated_map_type(::schema_proto::MapType* map_type);

  void clear_type_related_values();
  TypeRelatedValuesCase type_related_values_case() const;
  // @@protoc_insertion_point(class_scope:schema_proto.DataType)
 private:
  void set_has_fixed_size_binary_type();
  void set_has_fixed_size_list_type();
  void set_has_dictionary_type();
  void set_has_map_type();

  inline bool has_type_related_values() const;
  inline void clear_has_type_related_values();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::schema_proto::Field > children_;
  int logic_type_;
  union TypeRelatedValuesUnion {
    TypeRelatedValuesUnion() {}
    ::schema_proto::FixedSizeBinaryType* fixed_size_binary_type_;
    ::schema_proto::FixedSizeListType* fixed_size_list_type_;
    ::schema_proto::DictionaryType* dictionary_type_;
    ::schema_proto::MapType* map_type_;
  } type_related_values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyValueMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schema_proto.KeyValueMetadata) */ {
 public:
  KeyValueMetadata();
  virtual ~KeyValueMetadata();

  KeyValueMetadata(const KeyValueMetadata& from);

  inline KeyValueMetadata& operator=(const KeyValueMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValueMetadata(KeyValueMetadata&& from) noexcept
    : KeyValueMetadata() {
    *this = ::std::move(from);
  }

  inline KeyValueMetadata& operator=(KeyValueMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValueMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyValueMetadata* internal_default_instance() {
    return reinterpret_cast<const KeyValueMetadata*>(
               &_KeyValueMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(KeyValueMetadata* other);
  friend void swap(KeyValueMetadata& a, KeyValueMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValueMetadata* New() const final {
    return CreateMaybeMessage<KeyValueMetadata>(NULL);
  }

  KeyValueMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyValueMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyValueMetadata& from);
  void MergeFrom(const KeyValueMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValueMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // repeated string values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:schema_proto.KeyValueMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Field : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schema_proto.Field) */ {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(Field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Field* other);
  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Field* New() const final {
    return CreateMaybeMessage<Field>(NULL);
  }

  Field* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Field>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .schema_proto.DataType data_type = 3;
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 3;
  private:
  const ::schema_proto::DataType& _internal_data_type() const;
  public:
  const ::schema_proto::DataType& data_type() const;
  ::schema_proto::DataType* release_data_type();
  ::schema_proto::DataType* mutable_data_type();
  void set_allocated_data_type(::schema_proto::DataType* data_type);

  // .schema_proto.KeyValueMetadata metadata = 4;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 4;
  private:
  const ::schema_proto::KeyValueMetadata& _internal_metadata() const;
  public:
  const ::schema_proto::KeyValueMetadata& metadata() const;
  ::schema_proto::KeyValueMetadata* release_metadata();
  ::schema_proto::KeyValueMetadata* mutable_metadata();
  void set_allocated_metadata(::schema_proto::KeyValueMetadata* metadata);

  // bool nullable = 2;
  void clear_nullable();
  static const int kNullableFieldNumber = 2;
  bool nullable() const;
  void set_nullable(bool value);

  // @@protoc_insertion_point(class_scope:schema_proto.Field)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::schema_proto::DataType* data_type_;
  ::schema_proto::KeyValueMetadata* metadata_;
  bool nullable_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SchemaOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schema_proto.SchemaOptions) */ {
 public:
  SchemaOptions();
  virtual ~SchemaOptions();

  SchemaOptions(const SchemaOptions& from);

  inline SchemaOptions& operator=(const SchemaOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SchemaOptions(SchemaOptions&& from) noexcept
    : SchemaOptions() {
    *this = ::std::move(from);
  }

  inline SchemaOptions& operator=(SchemaOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SchemaOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SchemaOptions* internal_default_instance() {
    return reinterpret_cast<const SchemaOptions*>(
               &_SchemaOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SchemaOptions* other);
  friend void swap(SchemaOptions& a, SchemaOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SchemaOptions* New() const final {
    return CreateMaybeMessage<SchemaOptions>(NULL);
  }

  SchemaOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SchemaOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SchemaOptions& from);
  void MergeFrom(const SchemaOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string primary_column = 1;
  void clear_primary_column();
  static const int kPrimaryColumnFieldNumber = 1;
  const ::std::string& primary_column() const;
  void set_primary_column(const ::std::string& value);
  #if LANG_CXX11
  void set_primary_column(::std::string&& value);
  #endif
  void set_primary_column(const char* value);
  void set_primary_column(const char* value, size_t size);
  ::std::string* mutable_primary_column();
  ::std::string* release_primary_column();
  void set_allocated_primary_column(::std::string* primary_column);

  // string version_column = 2;
  void clear_version_column();
  static const int kVersionColumnFieldNumber = 2;
  const ::std::string& version_column() const;
  void set_version_column(const ::std::string& value);
  #if LANG_CXX11
  void set_version_column(::std::string&& value);
  #endif
  void set_version_column(const char* value);
  void set_version_column(const char* value, size_t size);
  ::std::string* mutable_version_column();
  ::std::string* release_version_column();
  void set_allocated_version_column(::std::string* version_column);

  // string vector_column = 3;
  void clear_vector_column();
  static const int kVectorColumnFieldNumber = 3;
  const ::std::string& vector_column() const;
  void set_vector_column(const ::std::string& value);
  #if LANG_CXX11
  void set_vector_column(::std::string&& value);
  #endif
  void set_vector_column(const char* value);
  void set_vector_column(const char* value, size_t size);
  ::std::string* mutable_vector_column();
  ::std::string* release_vector_column();
  void set_allocated_vector_column(::std::string* vector_column);

  // @@protoc_insertion_point(class_scope:schema_proto.SchemaOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr primary_column_;
  ::google::protobuf::internal::ArenaStringPtr version_column_;
  ::google::protobuf::internal::ArenaStringPtr vector_column_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ArrowSchema : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schema_proto.ArrowSchema) */ {
 public:
  ArrowSchema();
  virtual ~ArrowSchema();

  ArrowSchema(const ArrowSchema& from);

  inline ArrowSchema& operator=(const ArrowSchema& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArrowSchema(ArrowSchema&& from) noexcept
    : ArrowSchema() {
    *this = ::std::move(from);
  }

  inline ArrowSchema& operator=(ArrowSchema&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ArrowSchema& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArrowSchema* internal_default_instance() {
    return reinterpret_cast<const ArrowSchema*>(
               &_ArrowSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ArrowSchema* other);
  friend void swap(ArrowSchema& a, ArrowSchema& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArrowSchema* New() const final {
    return CreateMaybeMessage<ArrowSchema>(NULL);
  }

  ArrowSchema* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArrowSchema>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArrowSchema& from);
  void MergeFrom(const ArrowSchema& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArrowSchema* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .schema_proto.Field fields = 1;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 1;
  ::schema_proto::Field* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::schema_proto::Field >*
      mutable_fields();
  const ::schema_proto::Field& fields(int index) const;
  ::schema_proto::Field* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::schema_proto::Field >&
      fields() const;

  // .schema_proto.KeyValueMetadata metadata = 3;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  private:
  const ::schema_proto::KeyValueMetadata& _internal_metadata() const;
  public:
  const ::schema_proto::KeyValueMetadata& metadata() const;
  ::schema_proto::KeyValueMetadata* release_metadata();
  ::schema_proto::KeyValueMetadata* mutable_metadata();
  void set_allocated_metadata(::schema_proto::KeyValueMetadata* metadata);

  // .schema_proto.Endianness endianness = 2;
  void clear_endianness();
  static const int kEndiannessFieldNumber = 2;
  ::schema_proto::Endianness endianness() const;
  void set_endianness(::schema_proto::Endianness value);

  // @@protoc_insertion_point(class_scope:schema_proto.ArrowSchema)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::schema_proto::Field > fields_;
  ::schema_proto::KeyValueMetadata* metadata_;
  int endianness_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Schema : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schema_proto.Schema) */ {
 public:
  Schema();
  virtual ~Schema();

  Schema(const Schema& from);

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(Schema&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Schema& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Schema* other);
  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Schema* New() const final {
    return CreateMaybeMessage<Schema>(NULL);
  }

  Schema* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Schema& from);
  void MergeFrom(const Schema& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schema_proto.ArrowSchema arrow_schema = 1;
  bool has_arrow_schema() const;
  void clear_arrow_schema();
  static const int kArrowSchemaFieldNumber = 1;
  private:
  const ::schema_proto::ArrowSchema& _internal_arrow_schema() const;
  public:
  const ::schema_proto::ArrowSchema& arrow_schema() const;
  ::schema_proto::ArrowSchema* release_arrow_schema();
  ::schema_proto::ArrowSchema* mutable_arrow_schema();
  void set_allocated_arrow_schema(::schema_proto::ArrowSchema* arrow_schema);

  // .schema_proto.SchemaOptions schema_options = 2;
  bool has_schema_options() const;
  void clear_schema_options();
  static const int kSchemaOptionsFieldNumber = 2;
  private:
  const ::schema_proto::SchemaOptions& _internal_schema_options() const;
  public:
  const ::schema_proto::SchemaOptions& schema_options() const;
  ::schema_proto::SchemaOptions* release_schema_options();
  ::schema_proto::SchemaOptions* mutable_schema_options();
  void set_allocated_schema_options(::schema_proto::SchemaOptions* schema_options);

  // @@protoc_insertion_point(class_scope:schema_proto.Schema)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::schema_proto::ArrowSchema* arrow_schema_;
  ::schema_proto::SchemaOptions* schema_options_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FixedSizeBinaryType

// int32 byte_width = 1;
inline void FixedSizeBinaryType::clear_byte_width() {
  byte_width_ = 0;
}
inline ::google::protobuf::int32 FixedSizeBinaryType::byte_width() const {
  // @@protoc_insertion_point(field_get:schema_proto.FixedSizeBinaryType.byte_width)
  return byte_width_;
}
inline void FixedSizeBinaryType::set_byte_width(::google::protobuf::int32 value) {
  
  byte_width_ = value;
  // @@protoc_insertion_point(field_set:schema_proto.FixedSizeBinaryType.byte_width)
}

// -------------------------------------------------------------------

// FixedSizeListType

// int32 list_size = 1;
inline void FixedSizeListType::clear_list_size() {
  list_size_ = 0;
}
inline ::google::protobuf::int32 FixedSizeListType::list_size() const {
  // @@protoc_insertion_point(field_get:schema_proto.FixedSizeListType.list_size)
  return list_size_;
}
inline void FixedSizeListType::set_list_size(::google::protobuf::int32 value) {
  
  list_size_ = value;
  // @@protoc_insertion_point(field_set:schema_proto.FixedSizeListType.list_size)
}

// -------------------------------------------------------------------

// DictionaryType

// .schema_proto.DataType index_type = 1;
inline bool DictionaryType::has_index_type() const {
  return this != internal_default_instance() && index_type_ != NULL;
}
inline void DictionaryType::clear_index_type() {
  if (GetArenaNoVirtual() == NULL && index_type_ != NULL) {
    delete index_type_;
  }
  index_type_ = NULL;
}
inline const ::schema_proto::DataType& DictionaryType::_internal_index_type() const {
  return *index_type_;
}
inline const ::schema_proto::DataType& DictionaryType::index_type() const {
  const ::schema_proto::DataType* p = index_type_;
  // @@protoc_insertion_point(field_get:schema_proto.DictionaryType.index_type)
  return p != NULL ? *p : *reinterpret_cast<const ::schema_proto::DataType*>(
      &::schema_proto::_DataType_default_instance_);
}
inline ::schema_proto::DataType* DictionaryType::release_index_type() {
  // @@protoc_insertion_point(field_release:schema_proto.DictionaryType.index_type)
  
  ::schema_proto::DataType* temp = index_type_;
  index_type_ = NULL;
  return temp;
}
inline ::schema_proto::DataType* DictionaryType::mutable_index_type() {
  
  if (index_type_ == NULL) {
    auto* p = CreateMaybeMessage<::schema_proto::DataType>(GetArenaNoVirtual());
    index_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schema_proto.DictionaryType.index_type)
  return index_type_;
}
inline void DictionaryType::set_allocated_index_type(::schema_proto::DataType* index_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete index_type_;
  }
  if (index_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      index_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, index_type, submessage_arena);
    }
    
  } else {
    
  }
  index_type_ = index_type;
  // @@protoc_insertion_point(field_set_allocated:schema_proto.DictionaryType.index_type)
}

// .schema_proto.DataType value_type = 2;
inline bool DictionaryType::has_value_type() const {
  return this != internal_default_instance() && value_type_ != NULL;
}
inline void DictionaryType::clear_value_type() {
  if (GetArenaNoVirtual() == NULL && value_type_ != NULL) {
    delete value_type_;
  }
  value_type_ = NULL;
}
inline const ::schema_proto::DataType& DictionaryType::_internal_value_type() const {
  return *value_type_;
}
inline const ::schema_proto::DataType& DictionaryType::value_type() const {
  const ::schema_proto::DataType* p = value_type_;
  // @@protoc_insertion_point(field_get:schema_proto.DictionaryType.value_type)
  return p != NULL ? *p : *reinterpret_cast<const ::schema_proto::DataType*>(
      &::schema_proto::_DataType_default_instance_);
}
inline ::schema_proto::DataType* DictionaryType::release_value_type() {
  // @@protoc_insertion_point(field_release:schema_proto.DictionaryType.value_type)
  
  ::schema_proto::DataType* temp = value_type_;
  value_type_ = NULL;
  return temp;
}
inline ::schema_proto::DataType* DictionaryType::mutable_value_type() {
  
  if (value_type_ == NULL) {
    auto* p = CreateMaybeMessage<::schema_proto::DataType>(GetArenaNoVirtual());
    value_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schema_proto.DictionaryType.value_type)
  return value_type_;
}
inline void DictionaryType::set_allocated_value_type(::schema_proto::DataType* value_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_type_;
  }
  if (value_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value_type, submessage_arena);
    }
    
  } else {
    
  }
  value_type_ = value_type;
  // @@protoc_insertion_point(field_set_allocated:schema_proto.DictionaryType.value_type)
}

// bool ordered = 3;
inline void DictionaryType::clear_ordered() {
  ordered_ = false;
}
inline bool DictionaryType::ordered() const {
  // @@protoc_insertion_point(field_get:schema_proto.DictionaryType.ordered)
  return ordered_;
}
inline void DictionaryType::set_ordered(bool value) {
  
  ordered_ = value;
  // @@protoc_insertion_point(field_set:schema_proto.DictionaryType.ordered)
}

// -------------------------------------------------------------------

// MapType

// bool keys_sorted = 1;
inline void MapType::clear_keys_sorted() {
  keys_sorted_ = false;
}
inline bool MapType::keys_sorted() const {
  // @@protoc_insertion_point(field_get:schema_proto.MapType.keys_sorted)
  return keys_sorted_;
}
inline void MapType::set_keys_sorted(bool value) {
  
  keys_sorted_ = value;
  // @@protoc_insertion_point(field_set:schema_proto.MapType.keys_sorted)
}

// -------------------------------------------------------------------

// DataType

// .schema_proto.FixedSizeBinaryType fixed_size_binary_type = 1;
inline bool DataType::has_fixed_size_binary_type() const {
  return type_related_values_case() == kFixedSizeBinaryType;
}
inline void DataType::set_has_fixed_size_binary_type() {
  _oneof_case_[0] = kFixedSizeBinaryType;
}
inline void DataType::clear_fixed_size_binary_type() {
  if (has_fixed_size_binary_type()) {
    delete type_related_values_.fixed_size_binary_type_;
    clear_has_type_related_values();
  }
}
inline const ::schema_proto::FixedSizeBinaryType& DataType::_internal_fixed_size_binary_type() const {
  return *type_related_values_.fixed_size_binary_type_;
}
inline ::schema_proto::FixedSizeBinaryType* DataType::release_fixed_size_binary_type() {
  // @@protoc_insertion_point(field_release:schema_proto.DataType.fixed_size_binary_type)
  if (has_fixed_size_binary_type()) {
    clear_has_type_related_values();
      ::schema_proto::FixedSizeBinaryType* temp = type_related_values_.fixed_size_binary_type_;
    type_related_values_.fixed_size_binary_type_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::schema_proto::FixedSizeBinaryType& DataType::fixed_size_binary_type() const {
  // @@protoc_insertion_point(field_get:schema_proto.DataType.fixed_size_binary_type)
  return has_fixed_size_binary_type()
      ? *type_related_values_.fixed_size_binary_type_
      : *reinterpret_cast< ::schema_proto::FixedSizeBinaryType*>(&::schema_proto::_FixedSizeBinaryType_default_instance_);
}
inline ::schema_proto::FixedSizeBinaryType* DataType::mutable_fixed_size_binary_type() {
  if (!has_fixed_size_binary_type()) {
    clear_type_related_values();
    set_has_fixed_size_binary_type();
    type_related_values_.fixed_size_binary_type_ = CreateMaybeMessage< ::schema_proto::FixedSizeBinaryType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:schema_proto.DataType.fixed_size_binary_type)
  return type_related_values_.fixed_size_binary_type_;
}

// .schema_proto.FixedSizeListType fixed_size_list_type = 2;
inline bool DataType::has_fixed_size_list_type() const {
  return type_related_values_case() == kFixedSizeListType;
}
inline void DataType::set_has_fixed_size_list_type() {
  _oneof_case_[0] = kFixedSizeListType;
}
inline void DataType::clear_fixed_size_list_type() {
  if (has_fixed_size_list_type()) {
    delete type_related_values_.fixed_size_list_type_;
    clear_has_type_related_values();
  }
}
inline const ::schema_proto::FixedSizeListType& DataType::_internal_fixed_size_list_type() const {
  return *type_related_values_.fixed_size_list_type_;
}
inline ::schema_proto::FixedSizeListType* DataType::release_fixed_size_list_type() {
  // @@protoc_insertion_point(field_release:schema_proto.DataType.fixed_size_list_type)
  if (has_fixed_size_list_type()) {
    clear_has_type_related_values();
      ::schema_proto::FixedSizeListType* temp = type_related_values_.fixed_size_list_type_;
    type_related_values_.fixed_size_list_type_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::schema_proto::FixedSizeListType& DataType::fixed_size_list_type() const {
  // @@protoc_insertion_point(field_get:schema_proto.DataType.fixed_size_list_type)
  return has_fixed_size_list_type()
      ? *type_related_values_.fixed_size_list_type_
      : *reinterpret_cast< ::schema_proto::FixedSizeListType*>(&::schema_proto::_FixedSizeListType_default_instance_);
}
inline ::schema_proto::FixedSizeListType* DataType::mutable_fixed_size_list_type() {
  if (!has_fixed_size_list_type()) {
    clear_type_related_values();
    set_has_fixed_size_list_type();
    type_related_values_.fixed_size_list_type_ = CreateMaybeMessage< ::schema_proto::FixedSizeListType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:schema_proto.DataType.fixed_size_list_type)
  return type_related_values_.fixed_size_list_type_;
}

// .schema_proto.DictionaryType dictionary_type = 3;
inline bool DataType::has_dictionary_type() const {
  return type_related_values_case() == kDictionaryType;
}
inline void DataType::set_has_dictionary_type() {
  _oneof_case_[0] = kDictionaryType;
}
inline void DataType::clear_dictionary_type() {
  if (has_dictionary_type()) {
    delete type_related_values_.dictionary_type_;
    clear_has_type_related_values();
  }
}
inline const ::schema_proto::DictionaryType& DataType::_internal_dictionary_type() const {
  return *type_related_values_.dictionary_type_;
}
inline ::schema_proto::DictionaryType* DataType::release_dictionary_type() {
  // @@protoc_insertion_point(field_release:schema_proto.DataType.dictionary_type)
  if (has_dictionary_type()) {
    clear_has_type_related_values();
      ::schema_proto::DictionaryType* temp = type_related_values_.dictionary_type_;
    type_related_values_.dictionary_type_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::schema_proto::DictionaryType& DataType::dictionary_type() const {
  // @@protoc_insertion_point(field_get:schema_proto.DataType.dictionary_type)
  return has_dictionary_type()
      ? *type_related_values_.dictionary_type_
      : *reinterpret_cast< ::schema_proto::DictionaryType*>(&::schema_proto::_DictionaryType_default_instance_);
}
inline ::schema_proto::DictionaryType* DataType::mutable_dictionary_type() {
  if (!has_dictionary_type()) {
    clear_type_related_values();
    set_has_dictionary_type();
    type_related_values_.dictionary_type_ = CreateMaybeMessage< ::schema_proto::DictionaryType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:schema_proto.DataType.dictionary_type)
  return type_related_values_.dictionary_type_;
}

// .schema_proto.MapType map_type = 4;
inline bool DataType::has_map_type() const {
  return type_related_values_case() == kMapType;
}
inline void DataType::set_has_map_type() {
  _oneof_case_[0] = kMapType;
}
inline void DataType::clear_map_type() {
  if (has_map_type()) {
    delete type_related_values_.map_type_;
    clear_has_type_related_values();
  }
}
inline const ::schema_proto::MapType& DataType::_internal_map_type() const {
  return *type_related_values_.map_type_;
}
inline ::schema_proto::MapType* DataType::release_map_type() {
  // @@protoc_insertion_point(field_release:schema_proto.DataType.map_type)
  if (has_map_type()) {
    clear_has_type_related_values();
      ::schema_proto::MapType* temp = type_related_values_.map_type_;
    type_related_values_.map_type_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::schema_proto::MapType& DataType::map_type() const {
  // @@protoc_insertion_point(field_get:schema_proto.DataType.map_type)
  return has_map_type()
      ? *type_related_values_.map_type_
      : *reinterpret_cast< ::schema_proto::MapType*>(&::schema_proto::_MapType_default_instance_);
}
inline ::schema_proto::MapType* DataType::mutable_map_type() {
  if (!has_map_type()) {
    clear_type_related_values();
    set_has_map_type();
    type_related_values_.map_type_ = CreateMaybeMessage< ::schema_proto::MapType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:schema_proto.DataType.map_type)
  return type_related_values_.map_type_;
}

// .schema_proto.LogicType logic_type = 100;
inline void DataType::clear_logic_type() {
  logic_type_ = 0;
}
inline ::schema_proto::LogicType DataType::logic_type() const {
  // @@protoc_insertion_point(field_get:schema_proto.DataType.logic_type)
  return static_cast< ::schema_proto::LogicType >(logic_type_);
}
inline void DataType::set_logic_type(::schema_proto::LogicType value) {
  
  logic_type_ = value;
  // @@protoc_insertion_point(field_set:schema_proto.DataType.logic_type)
}

// repeated .schema_proto.Field children = 101;
inline int DataType::children_size() const {
  return children_.size();
}
inline void DataType::clear_children() {
  children_.Clear();
}
inline ::schema_proto::Field* DataType::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:schema_proto.DataType.children)
  return children_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::schema_proto::Field >*
DataType::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:schema_proto.DataType.children)
  return &children_;
}
inline const ::schema_proto::Field& DataType::children(int index) const {
  // @@protoc_insertion_point(field_get:schema_proto.DataType.children)
  return children_.Get(index);
}
inline ::schema_proto::Field* DataType::add_children() {
  // @@protoc_insertion_point(field_add:schema_proto.DataType.children)
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::schema_proto::Field >&
DataType::children() const {
  // @@protoc_insertion_point(field_list:schema_proto.DataType.children)
  return children_;
}

inline bool DataType::has_type_related_values() const {
  return type_related_values_case() != TYPE_RELATED_VALUES_NOT_SET;
}
inline void DataType::clear_has_type_related_values() {
  _oneof_case_[0] = TYPE_RELATED_VALUES_NOT_SET;
}
inline DataType::TypeRelatedValuesCase DataType::type_related_values_case() const {
  return DataType::TypeRelatedValuesCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// KeyValueMetadata

// repeated string keys = 1;
inline int KeyValueMetadata::keys_size() const {
  return keys_.size();
}
inline void KeyValueMetadata::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& KeyValueMetadata::keys(int index) const {
  // @@protoc_insertion_point(field_get:schema_proto.KeyValueMetadata.keys)
  return keys_.Get(index);
}
inline ::std::string* KeyValueMetadata::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:schema_proto.KeyValueMetadata.keys)
  return keys_.Mutable(index);
}
inline void KeyValueMetadata::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:schema_proto.KeyValueMetadata.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void KeyValueMetadata::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:schema_proto.KeyValueMetadata.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void KeyValueMetadata::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:schema_proto.KeyValueMetadata.keys)
}
inline void KeyValueMetadata::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:schema_proto.KeyValueMetadata.keys)
}
inline ::std::string* KeyValueMetadata::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:schema_proto.KeyValueMetadata.keys)
  return keys_.Add();
}
inline void KeyValueMetadata::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:schema_proto.KeyValueMetadata.keys)
}
#if LANG_CXX11
inline void KeyValueMetadata::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:schema_proto.KeyValueMetadata.keys)
}
#endif
inline void KeyValueMetadata::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:schema_proto.KeyValueMetadata.keys)
}
inline void KeyValueMetadata::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:schema_proto.KeyValueMetadata.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
KeyValueMetadata::keys() const {
  // @@protoc_insertion_point(field_list:schema_proto.KeyValueMetadata.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
KeyValueMetadata::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:schema_proto.KeyValueMetadata.keys)
  return &keys_;
}

// repeated string values = 2;
inline int KeyValueMetadata::values_size() const {
  return values_.size();
}
inline void KeyValueMetadata::clear_values() {
  values_.Clear();
}
inline const ::std::string& KeyValueMetadata::values(int index) const {
  // @@protoc_insertion_point(field_get:schema_proto.KeyValueMetadata.values)
  return values_.Get(index);
}
inline ::std::string* KeyValueMetadata::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:schema_proto.KeyValueMetadata.values)
  return values_.Mutable(index);
}
inline void KeyValueMetadata::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:schema_proto.KeyValueMetadata.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void KeyValueMetadata::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:schema_proto.KeyValueMetadata.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void KeyValueMetadata::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:schema_proto.KeyValueMetadata.values)
}
inline void KeyValueMetadata::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:schema_proto.KeyValueMetadata.values)
}
inline ::std::string* KeyValueMetadata::add_values() {
  // @@protoc_insertion_point(field_add_mutable:schema_proto.KeyValueMetadata.values)
  return values_.Add();
}
inline void KeyValueMetadata::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:schema_proto.KeyValueMetadata.values)
}
#if LANG_CXX11
inline void KeyValueMetadata::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:schema_proto.KeyValueMetadata.values)
}
#endif
inline void KeyValueMetadata::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:schema_proto.KeyValueMetadata.values)
}
inline void KeyValueMetadata::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:schema_proto.KeyValueMetadata.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
KeyValueMetadata::values() const {
  // @@protoc_insertion_point(field_list:schema_proto.KeyValueMetadata.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
KeyValueMetadata::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:schema_proto.KeyValueMetadata.values)
  return &values_;
}

// -------------------------------------------------------------------

// Field

// string name = 1;
inline void Field::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Field::name() const {
  // @@protoc_insertion_point(field_get:schema_proto.Field.name)
  return name_.GetNoArena();
}
inline void Field::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schema_proto.Field.name)
}
#if LANG_CXX11
inline void Field::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:schema_proto.Field.name)
}
#endif
inline void Field::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schema_proto.Field.name)
}
inline void Field::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schema_proto.Field.name)
}
inline ::std::string* Field::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:schema_proto.Field.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_name() {
  // @@protoc_insertion_point(field_release:schema_proto.Field.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:schema_proto.Field.name)
}

// bool nullable = 2;
inline void Field::clear_nullable() {
  nullable_ = false;
}
inline bool Field::nullable() const {
  // @@protoc_insertion_point(field_get:schema_proto.Field.nullable)
  return nullable_;
}
inline void Field::set_nullable(bool value) {
  
  nullable_ = value;
  // @@protoc_insertion_point(field_set:schema_proto.Field.nullable)
}

// .schema_proto.DataType data_type = 3;
inline bool Field::has_data_type() const {
  return this != internal_default_instance() && data_type_ != NULL;
}
inline void Field::clear_data_type() {
  if (GetArenaNoVirtual() == NULL && data_type_ != NULL) {
    delete data_type_;
  }
  data_type_ = NULL;
}
inline const ::schema_proto::DataType& Field::_internal_data_type() const {
  return *data_type_;
}
inline const ::schema_proto::DataType& Field::data_type() const {
  const ::schema_proto::DataType* p = data_type_;
  // @@protoc_insertion_point(field_get:schema_proto.Field.data_type)
  return p != NULL ? *p : *reinterpret_cast<const ::schema_proto::DataType*>(
      &::schema_proto::_DataType_default_instance_);
}
inline ::schema_proto::DataType* Field::release_data_type() {
  // @@protoc_insertion_point(field_release:schema_proto.Field.data_type)
  
  ::schema_proto::DataType* temp = data_type_;
  data_type_ = NULL;
  return temp;
}
inline ::schema_proto::DataType* Field::mutable_data_type() {
  
  if (data_type_ == NULL) {
    auto* p = CreateMaybeMessage<::schema_proto::DataType>(GetArenaNoVirtual());
    data_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schema_proto.Field.data_type)
  return data_type_;
}
inline void Field::set_allocated_data_type(::schema_proto::DataType* data_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_type_;
  }
  if (data_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data_type, submessage_arena);
    }
    
  } else {
    
  }
  data_type_ = data_type;
  // @@protoc_insertion_point(field_set_allocated:schema_proto.Field.data_type)
}

// .schema_proto.KeyValueMetadata metadata = 4;
inline bool Field::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void Field::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) {
    delete metadata_;
  }
  metadata_ = NULL;
}
inline const ::schema_proto::KeyValueMetadata& Field::_internal_metadata() const {
  return *metadata_;
}
inline const ::schema_proto::KeyValueMetadata& Field::metadata() const {
  const ::schema_proto::KeyValueMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:schema_proto.Field.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::schema_proto::KeyValueMetadata*>(
      &::schema_proto::_KeyValueMetadata_default_instance_);
}
inline ::schema_proto::KeyValueMetadata* Field::release_metadata() {
  // @@protoc_insertion_point(field_release:schema_proto.Field.metadata)
  
  ::schema_proto::KeyValueMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::schema_proto::KeyValueMetadata* Field::mutable_metadata() {
  
  if (metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::schema_proto::KeyValueMetadata>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schema_proto.Field.metadata)
  return metadata_;
}
inline void Field::set_allocated_metadata(::schema_proto::KeyValueMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:schema_proto.Field.metadata)
}

// -------------------------------------------------------------------

// SchemaOptions

// string primary_column = 1;
inline void SchemaOptions::clear_primary_column() {
  primary_column_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SchemaOptions::primary_column() const {
  // @@protoc_insertion_point(field_get:schema_proto.SchemaOptions.primary_column)
  return primary_column_.GetNoArena();
}
inline void SchemaOptions::set_primary_column(const ::std::string& value) {
  
  primary_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schema_proto.SchemaOptions.primary_column)
}
#if LANG_CXX11
inline void SchemaOptions::set_primary_column(::std::string&& value) {
  
  primary_column_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:schema_proto.SchemaOptions.primary_column)
}
#endif
inline void SchemaOptions::set_primary_column(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schema_proto.SchemaOptions.primary_column)
}
inline void SchemaOptions::set_primary_column(const char* value, size_t size) {
  
  primary_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schema_proto.SchemaOptions.primary_column)
}
inline ::std::string* SchemaOptions::mutable_primary_column() {
  
  // @@protoc_insertion_point(field_mutable:schema_proto.SchemaOptions.primary_column)
  return primary_column_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SchemaOptions::release_primary_column() {
  // @@protoc_insertion_point(field_release:schema_proto.SchemaOptions.primary_column)
  
  return primary_column_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SchemaOptions::set_allocated_primary_column(::std::string* primary_column) {
  if (primary_column != NULL) {
    
  } else {
    
  }
  primary_column_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary_column);
  // @@protoc_insertion_point(field_set_allocated:schema_proto.SchemaOptions.primary_column)
}

// string version_column = 2;
inline void SchemaOptions::clear_version_column() {
  version_column_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SchemaOptions::version_column() const {
  // @@protoc_insertion_point(field_get:schema_proto.SchemaOptions.version_column)
  return version_column_.GetNoArena();
}
inline void SchemaOptions::set_version_column(const ::std::string& value) {
  
  version_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schema_proto.SchemaOptions.version_column)
}
#if LANG_CXX11
inline void SchemaOptions::set_version_column(::std::string&& value) {
  
  version_column_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:schema_proto.SchemaOptions.version_column)
}
#endif
inline void SchemaOptions::set_version_column(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schema_proto.SchemaOptions.version_column)
}
inline void SchemaOptions::set_version_column(const char* value, size_t size) {
  
  version_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schema_proto.SchemaOptions.version_column)
}
inline ::std::string* SchemaOptions::mutable_version_column() {
  
  // @@protoc_insertion_point(field_mutable:schema_proto.SchemaOptions.version_column)
  return version_column_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SchemaOptions::release_version_column() {
  // @@protoc_insertion_point(field_release:schema_proto.SchemaOptions.version_column)
  
  return version_column_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SchemaOptions::set_allocated_version_column(::std::string* version_column) {
  if (version_column != NULL) {
    
  } else {
    
  }
  version_column_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version_column);
  // @@protoc_insertion_point(field_set_allocated:schema_proto.SchemaOptions.version_column)
}

// string vector_column = 3;
inline void SchemaOptions::clear_vector_column() {
  vector_column_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SchemaOptions::vector_column() const {
  // @@protoc_insertion_point(field_get:schema_proto.SchemaOptions.vector_column)
  return vector_column_.GetNoArena();
}
inline void SchemaOptions::set_vector_column(const ::std::string& value) {
  
  vector_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schema_proto.SchemaOptions.vector_column)
}
#if LANG_CXX11
inline void SchemaOptions::set_vector_column(::std::string&& value) {
  
  vector_column_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:schema_proto.SchemaOptions.vector_column)
}
#endif
inline void SchemaOptions::set_vector_column(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vector_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schema_proto.SchemaOptions.vector_column)
}
inline void SchemaOptions::set_vector_column(const char* value, size_t size) {
  
  vector_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schema_proto.SchemaOptions.vector_column)
}
inline ::std::string* SchemaOptions::mutable_vector_column() {
  
  // @@protoc_insertion_point(field_mutable:schema_proto.SchemaOptions.vector_column)
  return vector_column_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SchemaOptions::release_vector_column() {
  // @@protoc_insertion_point(field_release:schema_proto.SchemaOptions.vector_column)
  
  return vector_column_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SchemaOptions::set_allocated_vector_column(::std::string* vector_column) {
  if (vector_column != NULL) {
    
  } else {
    
  }
  vector_column_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vector_column);
  // @@protoc_insertion_point(field_set_allocated:schema_proto.SchemaOptions.vector_column)
}

// -------------------------------------------------------------------

// ArrowSchema

// repeated .schema_proto.Field fields = 1;
inline int ArrowSchema::fields_size() const {
  return fields_.size();
}
inline void ArrowSchema::clear_fields() {
  fields_.Clear();
}
inline ::schema_proto::Field* ArrowSchema::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:schema_proto.ArrowSchema.fields)
  return fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::schema_proto::Field >*
ArrowSchema::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:schema_proto.ArrowSchema.fields)
  return &fields_;
}
inline const ::schema_proto::Field& ArrowSchema::fields(int index) const {
  // @@protoc_insertion_point(field_get:schema_proto.ArrowSchema.fields)
  return fields_.Get(index);
}
inline ::schema_proto::Field* ArrowSchema::add_fields() {
  // @@protoc_insertion_point(field_add:schema_proto.ArrowSchema.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::schema_proto::Field >&
ArrowSchema::fields() const {
  // @@protoc_insertion_point(field_list:schema_proto.ArrowSchema.fields)
  return fields_;
}

// .schema_proto.Endianness endianness = 2;
inline void ArrowSchema::clear_endianness() {
  endianness_ = 0;
}
inline ::schema_proto::Endianness ArrowSchema::endianness() const {
  // @@protoc_insertion_point(field_get:schema_proto.ArrowSchema.endianness)
  return static_cast< ::schema_proto::Endianness >(endianness_);
}
inline void ArrowSchema::set_endianness(::schema_proto::Endianness value) {
  
  endianness_ = value;
  // @@protoc_insertion_point(field_set:schema_proto.ArrowSchema.endianness)
}

// .schema_proto.KeyValueMetadata metadata = 3;
inline bool ArrowSchema::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void ArrowSchema::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) {
    delete metadata_;
  }
  metadata_ = NULL;
}
inline const ::schema_proto::KeyValueMetadata& ArrowSchema::_internal_metadata() const {
  return *metadata_;
}
inline const ::schema_proto::KeyValueMetadata& ArrowSchema::metadata() const {
  const ::schema_proto::KeyValueMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:schema_proto.ArrowSchema.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::schema_proto::KeyValueMetadata*>(
      &::schema_proto::_KeyValueMetadata_default_instance_);
}
inline ::schema_proto::KeyValueMetadata* ArrowSchema::release_metadata() {
  // @@protoc_insertion_point(field_release:schema_proto.ArrowSchema.metadata)
  
  ::schema_proto::KeyValueMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::schema_proto::KeyValueMetadata* ArrowSchema::mutable_metadata() {
  
  if (metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::schema_proto::KeyValueMetadata>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schema_proto.ArrowSchema.metadata)
  return metadata_;
}
inline void ArrowSchema::set_allocated_metadata(::schema_proto::KeyValueMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:schema_proto.ArrowSchema.metadata)
}

// -------------------------------------------------------------------

// Schema

// .schema_proto.ArrowSchema arrow_schema = 1;
inline bool Schema::has_arrow_schema() const {
  return this != internal_default_instance() && arrow_schema_ != NULL;
}
inline void Schema::clear_arrow_schema() {
  if (GetArenaNoVirtual() == NULL && arrow_schema_ != NULL) {
    delete arrow_schema_;
  }
  arrow_schema_ = NULL;
}
inline const ::schema_proto::ArrowSchema& Schema::_internal_arrow_schema() const {
  return *arrow_schema_;
}
inline const ::schema_proto::ArrowSchema& Schema::arrow_schema() const {
  const ::schema_proto::ArrowSchema* p = arrow_schema_;
  // @@protoc_insertion_point(field_get:schema_proto.Schema.arrow_schema)
  return p != NULL ? *p : *reinterpret_cast<const ::schema_proto::ArrowSchema*>(
      &::schema_proto::_ArrowSchema_default_instance_);
}
inline ::schema_proto::ArrowSchema* Schema::release_arrow_schema() {
  // @@protoc_insertion_point(field_release:schema_proto.Schema.arrow_schema)
  
  ::schema_proto::ArrowSchema* temp = arrow_schema_;
  arrow_schema_ = NULL;
  return temp;
}
inline ::schema_proto::ArrowSchema* Schema::mutable_arrow_schema() {
  
  if (arrow_schema_ == NULL) {
    auto* p = CreateMaybeMessage<::schema_proto::ArrowSchema>(GetArenaNoVirtual());
    arrow_schema_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schema_proto.Schema.arrow_schema)
  return arrow_schema_;
}
inline void Schema::set_allocated_arrow_schema(::schema_proto::ArrowSchema* arrow_schema) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete arrow_schema_;
  }
  if (arrow_schema) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      arrow_schema = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, arrow_schema, submessage_arena);
    }
    
  } else {
    
  }
  arrow_schema_ = arrow_schema;
  // @@protoc_insertion_point(field_set_allocated:schema_proto.Schema.arrow_schema)
}

// .schema_proto.SchemaOptions schema_options = 2;
inline bool Schema::has_schema_options() const {
  return this != internal_default_instance() && schema_options_ != NULL;
}
inline void Schema::clear_schema_options() {
  if (GetArenaNoVirtual() == NULL && schema_options_ != NULL) {
    delete schema_options_;
  }
  schema_options_ = NULL;
}
inline const ::schema_proto::SchemaOptions& Schema::_internal_schema_options() const {
  return *schema_options_;
}
inline const ::schema_proto::SchemaOptions& Schema::schema_options() const {
  const ::schema_proto::SchemaOptions* p = schema_options_;
  // @@protoc_insertion_point(field_get:schema_proto.Schema.schema_options)
  return p != NULL ? *p : *reinterpret_cast<const ::schema_proto::SchemaOptions*>(
      &::schema_proto::_SchemaOptions_default_instance_);
}
inline ::schema_proto::SchemaOptions* Schema::release_schema_options() {
  // @@protoc_insertion_point(field_release:schema_proto.Schema.schema_options)
  
  ::schema_proto::SchemaOptions* temp = schema_options_;
  schema_options_ = NULL;
  return temp;
}
inline ::schema_proto::SchemaOptions* Schema::mutable_schema_options() {
  
  if (schema_options_ == NULL) {
    auto* p = CreateMaybeMessage<::schema_proto::SchemaOptions>(GetArenaNoVirtual());
    schema_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schema_proto.Schema.schema_options)
  return schema_options_;
}
inline void Schema::set_allocated_schema_options(::schema_proto::SchemaOptions* schema_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete schema_options_;
  }
  if (schema_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      schema_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, schema_options, submessage_arena);
    }
    
  } else {
    
  }
  schema_options_ = schema_options;
  // @@protoc_insertion_point(field_set_allocated:schema_proto.Schema.schema_options)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace schema_proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::schema_proto::LogicType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::schema_proto::LogicType>() {
  return ::schema_proto::LogicType_descriptor();
}
template <> struct is_proto_enum< ::schema_proto::Endianness> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::schema_proto::Endianness>() {
  return ::schema_proto::Endianness_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_schema_2eproto
