// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: manifest.proto

#ifndef PROTOBUF_INCLUDED_manifest_2eproto
#define PROTOBUF_INCLUDED_manifest_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "schema.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_manifest_2eproto 

namespace protobuf_manifest_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_manifest_2eproto
namespace manifest {
class Manifest;
class ManifestDefaultTypeInternal;
extern ManifestDefaultTypeInternal _Manifest_default_instance_;
class SpaceOption;
class SpaceOptionDefaultTypeInternal;
extern SpaceOptionDefaultTypeInternal _SpaceOption_default_instance_;
}  // namespace manifest
namespace google {
namespace protobuf {
template<> ::manifest::Manifest* Arena::CreateMaybeMessage<::manifest::Manifest>(Arena*);
template<> ::manifest::SpaceOption* Arena::CreateMaybeMessage<::manifest::SpaceOption>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace manifest {

// ===================================================================

class SpaceOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:manifest.SpaceOption) */ {
 public:
  SpaceOption();
  virtual ~SpaceOption();

  SpaceOption(const SpaceOption& from);

  inline SpaceOption& operator=(const SpaceOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpaceOption(SpaceOption&& from) noexcept
    : SpaceOption() {
    *this = ::std::move(from);
  }

  inline SpaceOption& operator=(SpaceOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SpaceOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpaceOption* internal_default_instance() {
    return reinterpret_cast<const SpaceOption*>(
               &_SpaceOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SpaceOption* other);
  friend void swap(SpaceOption& a, SpaceOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpaceOption* New() const final {
    return CreateMaybeMessage<SpaceOption>(NULL);
  }

  SpaceOption* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpaceOption>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpaceOption& from);
  void MergeFrom(const SpaceOption& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpaceOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string primary_column = 2;
  void clear_primary_column();
  static const int kPrimaryColumnFieldNumber = 2;
  const ::std::string& primary_column() const;
  void set_primary_column(const ::std::string& value);
  #if LANG_CXX11
  void set_primary_column(::std::string&& value);
  #endif
  void set_primary_column(const char* value);
  void set_primary_column(const char* value, size_t size);
  ::std::string* mutable_primary_column();
  ::std::string* release_primary_column();
  void set_allocated_primary_column(::std::string* primary_column);

  // string version_column = 3;
  void clear_version_column();
  static const int kVersionColumnFieldNumber = 3;
  const ::std::string& version_column() const;
  void set_version_column(const ::std::string& value);
  #if LANG_CXX11
  void set_version_column(::std::string&& value);
  #endif
  void set_version_column(const char* value);
  void set_version_column(const char* value, size_t size);
  ::std::string* mutable_version_column();
  ::std::string* release_version_column();
  void set_allocated_version_column(::std::string* version_column);

  // string vector_column = 4;
  void clear_vector_column();
  static const int kVectorColumnFieldNumber = 4;
  const ::std::string& vector_column() const;
  void set_vector_column(const ::std::string& value);
  #if LANG_CXX11
  void set_vector_column(::std::string&& value);
  #endif
  void set_vector_column(const char* value);
  void set_vector_column(const char* value, size_t size);
  ::std::string* mutable_vector_column();
  ::std::string* release_vector_column();
  void set_allocated_vector_column(::std::string* vector_column);

  // @@protoc_insertion_point(class_scope:manifest.SpaceOption)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr primary_column_;
  ::google::protobuf::internal::ArenaStringPtr version_column_;
  ::google::protobuf::internal::ArenaStringPtr vector_column_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_manifest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Manifest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:manifest.Manifest) */ {
 public:
  Manifest();
  virtual ~Manifest();

  Manifest(const Manifest& from);

  inline Manifest& operator=(const Manifest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Manifest(Manifest&& from) noexcept
    : Manifest() {
    *this = ::std::move(from);
  }

  inline Manifest& operator=(Manifest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Manifest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Manifest* internal_default_instance() {
    return reinterpret_cast<const Manifest*>(
               &_Manifest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Manifest* other);
  friend void swap(Manifest& a, Manifest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Manifest* New() const final {
    return CreateMaybeMessage<Manifest>(NULL);
  }

  Manifest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Manifest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Manifest& from);
  void MergeFrom(const Manifest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Manifest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string scalar_files = 3;
  int scalar_files_size() const;
  void clear_scalar_files();
  static const int kScalarFilesFieldNumber = 3;
  const ::std::string& scalar_files(int index) const;
  ::std::string* mutable_scalar_files(int index);
  void set_scalar_files(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_scalar_files(int index, ::std::string&& value);
  #endif
  void set_scalar_files(int index, const char* value);
  void set_scalar_files(int index, const char* value, size_t size);
  ::std::string* add_scalar_files();
  void add_scalar_files(const ::std::string& value);
  #if LANG_CXX11
  void add_scalar_files(::std::string&& value);
  #endif
  void add_scalar_files(const char* value);
  void add_scalar_files(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& scalar_files() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_scalar_files();

  // repeated string vector_files = 4;
  int vector_files_size() const;
  void clear_vector_files();
  static const int kVectorFilesFieldNumber = 4;
  const ::std::string& vector_files(int index) const;
  ::std::string* mutable_vector_files(int index);
  void set_vector_files(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_vector_files(int index, ::std::string&& value);
  #endif
  void set_vector_files(int index, const char* value);
  void set_vector_files(int index, const char* value, size_t size);
  ::std::string* add_vector_files();
  void add_vector_files(const ::std::string& value);
  #if LANG_CXX11
  void add_vector_files(::std::string&& value);
  #endif
  void add_vector_files(const char* value);
  void add_vector_files(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& vector_files() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_vector_files();

  // repeated string delete_files = 5;
  int delete_files_size() const;
  void clear_delete_files();
  static const int kDeleteFilesFieldNumber = 5;
  const ::std::string& delete_files(int index) const;
  ::std::string* mutable_delete_files(int index);
  void set_delete_files(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_delete_files(int index, ::std::string&& value);
  #endif
  void set_delete_files(int index, const char* value);
  void set_delete_files(int index, const char* value, size_t size);
  ::std::string* add_delete_files();
  void add_delete_files(const ::std::string& value);
  #if LANG_CXX11
  void add_delete_files(::std::string&& value);
  #endif
  void add_delete_files(const char* value);
  void add_delete_files(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& delete_files() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_delete_files();

  // .manifest.SpaceOption options = 1;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 1;
  private:
  const ::manifest::SpaceOption& _internal_options() const;
  public:
  const ::manifest::SpaceOption& options() const;
  ::manifest::SpaceOption* release_options();
  ::manifest::SpaceOption* mutable_options();
  void set_allocated_options(::manifest::SpaceOption* options);

  // .schema.Schema schema = 2;
  bool has_schema() const;
  void clear_schema();
  static const int kSchemaFieldNumber = 2;
  private:
  const ::schema::Schema& _internal_schema() const;
  public:
  const ::schema::Schema& schema() const;
  ::schema::Schema* release_schema();
  ::schema::Schema* mutable_schema();
  void set_allocated_schema(::schema::Schema* schema);

  // @@protoc_insertion_point(class_scope:manifest.Manifest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> scalar_files_;
  ::google::protobuf::RepeatedPtrField< ::std::string> vector_files_;
  ::google::protobuf::RepeatedPtrField< ::std::string> delete_files_;
  ::manifest::SpaceOption* options_;
  ::schema::Schema* schema_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_manifest_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SpaceOption

// string path = 1;
inline void SpaceOption::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpaceOption::path() const {
  // @@protoc_insertion_point(field_get:manifest.SpaceOption.path)
  return path_.GetNoArena();
}
inline void SpaceOption::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:manifest.SpaceOption.path)
}
#if LANG_CXX11
inline void SpaceOption::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:manifest.SpaceOption.path)
}
#endif
inline void SpaceOption::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:manifest.SpaceOption.path)
}
inline void SpaceOption::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:manifest.SpaceOption.path)
}
inline ::std::string* SpaceOption::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:manifest.SpaceOption.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpaceOption::release_path() {
  // @@protoc_insertion_point(field_release:manifest.SpaceOption.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpaceOption::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:manifest.SpaceOption.path)
}

// string primary_column = 2;
inline void SpaceOption::clear_primary_column() {
  primary_column_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpaceOption::primary_column() const {
  // @@protoc_insertion_point(field_get:manifest.SpaceOption.primary_column)
  return primary_column_.GetNoArena();
}
inline void SpaceOption::set_primary_column(const ::std::string& value) {
  
  primary_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:manifest.SpaceOption.primary_column)
}
#if LANG_CXX11
inline void SpaceOption::set_primary_column(::std::string&& value) {
  
  primary_column_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:manifest.SpaceOption.primary_column)
}
#endif
inline void SpaceOption::set_primary_column(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:manifest.SpaceOption.primary_column)
}
inline void SpaceOption::set_primary_column(const char* value, size_t size) {
  
  primary_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:manifest.SpaceOption.primary_column)
}
inline ::std::string* SpaceOption::mutable_primary_column() {
  
  // @@protoc_insertion_point(field_mutable:manifest.SpaceOption.primary_column)
  return primary_column_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpaceOption::release_primary_column() {
  // @@protoc_insertion_point(field_release:manifest.SpaceOption.primary_column)
  
  return primary_column_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpaceOption::set_allocated_primary_column(::std::string* primary_column) {
  if (primary_column != NULL) {
    
  } else {
    
  }
  primary_column_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary_column);
  // @@protoc_insertion_point(field_set_allocated:manifest.SpaceOption.primary_column)
}

// string version_column = 3;
inline void SpaceOption::clear_version_column() {
  version_column_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpaceOption::version_column() const {
  // @@protoc_insertion_point(field_get:manifest.SpaceOption.version_column)
  return version_column_.GetNoArena();
}
inline void SpaceOption::set_version_column(const ::std::string& value) {
  
  version_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:manifest.SpaceOption.version_column)
}
#if LANG_CXX11
inline void SpaceOption::set_version_column(::std::string&& value) {
  
  version_column_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:manifest.SpaceOption.version_column)
}
#endif
inline void SpaceOption::set_version_column(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:manifest.SpaceOption.version_column)
}
inline void SpaceOption::set_version_column(const char* value, size_t size) {
  
  version_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:manifest.SpaceOption.version_column)
}
inline ::std::string* SpaceOption::mutable_version_column() {
  
  // @@protoc_insertion_point(field_mutable:manifest.SpaceOption.version_column)
  return version_column_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpaceOption::release_version_column() {
  // @@protoc_insertion_point(field_release:manifest.SpaceOption.version_column)
  
  return version_column_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpaceOption::set_allocated_version_column(::std::string* version_column) {
  if (version_column != NULL) {
    
  } else {
    
  }
  version_column_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version_column);
  // @@protoc_insertion_point(field_set_allocated:manifest.SpaceOption.version_column)
}

// string vector_column = 4;
inline void SpaceOption::clear_vector_column() {
  vector_column_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpaceOption::vector_column() const {
  // @@protoc_insertion_point(field_get:manifest.SpaceOption.vector_column)
  return vector_column_.GetNoArena();
}
inline void SpaceOption::set_vector_column(const ::std::string& value) {
  
  vector_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:manifest.SpaceOption.vector_column)
}
#if LANG_CXX11
inline void SpaceOption::set_vector_column(::std::string&& value) {
  
  vector_column_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:manifest.SpaceOption.vector_column)
}
#endif
inline void SpaceOption::set_vector_column(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vector_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:manifest.SpaceOption.vector_column)
}
inline void SpaceOption::set_vector_column(const char* value, size_t size) {
  
  vector_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:manifest.SpaceOption.vector_column)
}
inline ::std::string* SpaceOption::mutable_vector_column() {
  
  // @@protoc_insertion_point(field_mutable:manifest.SpaceOption.vector_column)
  return vector_column_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpaceOption::release_vector_column() {
  // @@protoc_insertion_point(field_release:manifest.SpaceOption.vector_column)
  
  return vector_column_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpaceOption::set_allocated_vector_column(::std::string* vector_column) {
  if (vector_column != NULL) {
    
  } else {
    
  }
  vector_column_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vector_column);
  // @@protoc_insertion_point(field_set_allocated:manifest.SpaceOption.vector_column)
}

// -------------------------------------------------------------------

// Manifest

// .manifest.SpaceOption options = 1;
inline bool Manifest::has_options() const {
  return this != internal_default_instance() && options_ != NULL;
}
inline void Manifest::clear_options() {
  if (GetArenaNoVirtual() == NULL && options_ != NULL) {
    delete options_;
  }
  options_ = NULL;
}
inline const ::manifest::SpaceOption& Manifest::_internal_options() const {
  return *options_;
}
inline const ::manifest::SpaceOption& Manifest::options() const {
  const ::manifest::SpaceOption* p = options_;
  // @@protoc_insertion_point(field_get:manifest.Manifest.options)
  return p != NULL ? *p : *reinterpret_cast<const ::manifest::SpaceOption*>(
      &::manifest::_SpaceOption_default_instance_);
}
inline ::manifest::SpaceOption* Manifest::release_options() {
  // @@protoc_insertion_point(field_release:manifest.Manifest.options)
  
  ::manifest::SpaceOption* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::manifest::SpaceOption* Manifest::mutable_options() {
  
  if (options_ == NULL) {
    auto* p = CreateMaybeMessage<::manifest::SpaceOption>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:manifest.Manifest.options)
  return options_;
}
inline void Manifest::set_allocated_options(::manifest::SpaceOption* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:manifest.Manifest.options)
}

// .schema.Schema schema = 2;
inline bool Manifest::has_schema() const {
  return this != internal_default_instance() && schema_ != NULL;
}
inline const ::schema::Schema& Manifest::_internal_schema() const {
  return *schema_;
}
inline const ::schema::Schema& Manifest::schema() const {
  const ::schema::Schema* p = schema_;
  // @@protoc_insertion_point(field_get:manifest.Manifest.schema)
  return p != NULL ? *p : *reinterpret_cast<const ::schema::Schema*>(
      &::schema::_Schema_default_instance_);
}
inline ::schema::Schema* Manifest::release_schema() {
  // @@protoc_insertion_point(field_release:manifest.Manifest.schema)
  
  ::schema::Schema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline ::schema::Schema* Manifest::mutable_schema() {
  
  if (schema_ == NULL) {
    auto* p = CreateMaybeMessage<::schema::Schema>(GetArenaNoVirtual());
    schema_ = p;
  }
  // @@protoc_insertion_point(field_mutable:manifest.Manifest.schema)
  return schema_;
}
inline void Manifest::set_allocated_schema(::schema::Schema* schema) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(schema_);
  }
  if (schema) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      schema = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:manifest.Manifest.schema)
}

// repeated string scalar_files = 3;
inline int Manifest::scalar_files_size() const {
  return scalar_files_.size();
}
inline void Manifest::clear_scalar_files() {
  scalar_files_.Clear();
}
inline const ::std::string& Manifest::scalar_files(int index) const {
  // @@protoc_insertion_point(field_get:manifest.Manifest.scalar_files)
  return scalar_files_.Get(index);
}
inline ::std::string* Manifest::mutable_scalar_files(int index) {
  // @@protoc_insertion_point(field_mutable:manifest.Manifest.scalar_files)
  return scalar_files_.Mutable(index);
}
inline void Manifest::set_scalar_files(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:manifest.Manifest.scalar_files)
  scalar_files_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Manifest::set_scalar_files(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:manifest.Manifest.scalar_files)
  scalar_files_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Manifest::set_scalar_files(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  scalar_files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:manifest.Manifest.scalar_files)
}
inline void Manifest::set_scalar_files(int index, const char* value, size_t size) {
  scalar_files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:manifest.Manifest.scalar_files)
}
inline ::std::string* Manifest::add_scalar_files() {
  // @@protoc_insertion_point(field_add_mutable:manifest.Manifest.scalar_files)
  return scalar_files_.Add();
}
inline void Manifest::add_scalar_files(const ::std::string& value) {
  scalar_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:manifest.Manifest.scalar_files)
}
#if LANG_CXX11
inline void Manifest::add_scalar_files(::std::string&& value) {
  scalar_files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:manifest.Manifest.scalar_files)
}
#endif
inline void Manifest::add_scalar_files(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  scalar_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:manifest.Manifest.scalar_files)
}
inline void Manifest::add_scalar_files(const char* value, size_t size) {
  scalar_files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:manifest.Manifest.scalar_files)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Manifest::scalar_files() const {
  // @@protoc_insertion_point(field_list:manifest.Manifest.scalar_files)
  return scalar_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Manifest::mutable_scalar_files() {
  // @@protoc_insertion_point(field_mutable_list:manifest.Manifest.scalar_files)
  return &scalar_files_;
}

// repeated string vector_files = 4;
inline int Manifest::vector_files_size() const {
  return vector_files_.size();
}
inline void Manifest::clear_vector_files() {
  vector_files_.Clear();
}
inline const ::std::string& Manifest::vector_files(int index) const {
  // @@protoc_insertion_point(field_get:manifest.Manifest.vector_files)
  return vector_files_.Get(index);
}
inline ::std::string* Manifest::mutable_vector_files(int index) {
  // @@protoc_insertion_point(field_mutable:manifest.Manifest.vector_files)
  return vector_files_.Mutable(index);
}
inline void Manifest::set_vector_files(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:manifest.Manifest.vector_files)
  vector_files_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Manifest::set_vector_files(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:manifest.Manifest.vector_files)
  vector_files_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Manifest::set_vector_files(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  vector_files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:manifest.Manifest.vector_files)
}
inline void Manifest::set_vector_files(int index, const char* value, size_t size) {
  vector_files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:manifest.Manifest.vector_files)
}
inline ::std::string* Manifest::add_vector_files() {
  // @@protoc_insertion_point(field_add_mutable:manifest.Manifest.vector_files)
  return vector_files_.Add();
}
inline void Manifest::add_vector_files(const ::std::string& value) {
  vector_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:manifest.Manifest.vector_files)
}
#if LANG_CXX11
inline void Manifest::add_vector_files(::std::string&& value) {
  vector_files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:manifest.Manifest.vector_files)
}
#endif
inline void Manifest::add_vector_files(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  vector_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:manifest.Manifest.vector_files)
}
inline void Manifest::add_vector_files(const char* value, size_t size) {
  vector_files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:manifest.Manifest.vector_files)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Manifest::vector_files() const {
  // @@protoc_insertion_point(field_list:manifest.Manifest.vector_files)
  return vector_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Manifest::mutable_vector_files() {
  // @@protoc_insertion_point(field_mutable_list:manifest.Manifest.vector_files)
  return &vector_files_;
}

// repeated string delete_files = 5;
inline int Manifest::delete_files_size() const {
  return delete_files_.size();
}
inline void Manifest::clear_delete_files() {
  delete_files_.Clear();
}
inline const ::std::string& Manifest::delete_files(int index) const {
  // @@protoc_insertion_point(field_get:manifest.Manifest.delete_files)
  return delete_files_.Get(index);
}
inline ::std::string* Manifest::mutable_delete_files(int index) {
  // @@protoc_insertion_point(field_mutable:manifest.Manifest.delete_files)
  return delete_files_.Mutable(index);
}
inline void Manifest::set_delete_files(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:manifest.Manifest.delete_files)
  delete_files_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Manifest::set_delete_files(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:manifest.Manifest.delete_files)
  delete_files_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Manifest::set_delete_files(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  delete_files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:manifest.Manifest.delete_files)
}
inline void Manifest::set_delete_files(int index, const char* value, size_t size) {
  delete_files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:manifest.Manifest.delete_files)
}
inline ::std::string* Manifest::add_delete_files() {
  // @@protoc_insertion_point(field_add_mutable:manifest.Manifest.delete_files)
  return delete_files_.Add();
}
inline void Manifest::add_delete_files(const ::std::string& value) {
  delete_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:manifest.Manifest.delete_files)
}
#if LANG_CXX11
inline void Manifest::add_delete_files(::std::string&& value) {
  delete_files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:manifest.Manifest.delete_files)
}
#endif
inline void Manifest::add_delete_files(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  delete_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:manifest.Manifest.delete_files)
}
inline void Manifest::add_delete_files(const char* value, size_t size) {
  delete_files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:manifest.Manifest.delete_files)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Manifest::delete_files() const {
  // @@protoc_insertion_point(field_list:manifest.Manifest.delete_files)
  return delete_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Manifest::mutable_delete_files() {
  // @@protoc_insertion_point(field_mutable_list:manifest.Manifest.delete_files)
  return &delete_files_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace manifest

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_manifest_2eproto
