// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: manifest.proto

#ifndef PROTOBUF_INCLUDED_manifest_2eproto
#define PROTOBUF_INCLUDED_manifest_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>   // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "schema.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_manifest_2eproto

namespace protobuf_manifest_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_manifest_2eproto
namespace manifest_proto {
class Manifest;
class ManifestDefaultTypeInternal;
extern ManifestDefaultTypeInternal _Manifest_default_instance_;
class SpaceOptions;
class SpaceOptionsDefaultTypeInternal;
extern SpaceOptionsDefaultTypeInternal _SpaceOptions_default_instance_;
}  // namespace manifest_proto
namespace google {
namespace protobuf {
template <>
::manifest_proto::Manifest* Arena::CreateMaybeMessage<::manifest_proto::Manifest>(Arena*);
template <>
::manifest_proto::SpaceOptions* Arena::CreateMaybeMessage<::manifest_proto::SpaceOptions>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace manifest_proto {

// ===================================================================

class SpaceOptions
    : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:manifest_proto.SpaceOptions) */ {
  public:
  SpaceOptions();
  virtual ~SpaceOptions();

  SpaceOptions(const SpaceOptions& from);

  inline SpaceOptions& operator=(const SpaceOptions& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  SpaceOptions(SpaceOptions&& from) noexcept : SpaceOptions() { *this = ::std::move(from); }

  inline SpaceOptions& operator=(SpaceOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from)
        InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SpaceOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpaceOptions* internal_default_instance() {
    return reinterpret_cast<const SpaceOptions*>(&_SpaceOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;

  void Swap(SpaceOptions* other);
  friend void swap(SpaceOptions& a, SpaceOptions& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline SpaceOptions* New() const final { return CreateMaybeMessage<SpaceOptions>(NULL); }

  SpaceOptions* New(::google::protobuf::Arena* arena) const final { return CreateMaybeMessage<SpaceOptions>(arena); }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpaceOptions& from);
  void MergeFrom(const SpaceOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(bool deterministic,
                                                                     ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpaceOptions* other);

  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

  public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri = 1;
  void clear_uri();
  static const int kUriFieldNumber = 1;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
#if LANG_CXX11
  void set_uri(::std::string&& value);
#endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // @@protoc_insertion_point(class_scope:manifest_proto.SpaceOptions)
  private:
  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_manifest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Manifest
    : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:manifest_proto.Manifest) */ {
  public:
  Manifest();
  virtual ~Manifest();

  Manifest(const Manifest& from);

  inline Manifest& operator=(const Manifest& from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  Manifest(Manifest&& from) noexcept : Manifest() { *this = ::std::move(from); }

  inline Manifest& operator=(Manifest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from)
        InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Manifest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Manifest* internal_default_instance() {
    return reinterpret_cast<const Manifest*>(&_Manifest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;

  void Swap(Manifest* other);
  friend void swap(Manifest& a, Manifest& b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline Manifest* New() const final { return CreateMaybeMessage<Manifest>(NULL); }

  Manifest* New(::google::protobuf::Arena* arena) const final { return CreateMaybeMessage<Manifest>(arena); }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Manifest& from);
  void MergeFrom(const Manifest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(bool deterministic,
                                                                     ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Manifest* other);

  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const { return NULL; }
  inline void* MaybeArenaPtr() const { return NULL; }

  public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string scalar_files = 3;
  int scalar_files_size() const;
  void clear_scalar_files();
  static const int kScalarFilesFieldNumber = 3;
  const ::std::string& scalar_files(int index) const;
  ::std::string* mutable_scalar_files(int index);
  void set_scalar_files(int index, const ::std::string& value);
#if LANG_CXX11
  void set_scalar_files(int index, ::std::string&& value);
#endif
  void set_scalar_files(int index, const char* value);
  void set_scalar_files(int index, const char* value, size_t size);
  ::std::string* add_scalar_files();
  void add_scalar_files(const ::std::string& value);
#if LANG_CXX11
  void add_scalar_files(::std::string&& value);
#endif
  void add_scalar_files(const char* value);
  void add_scalar_files(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& scalar_files() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_scalar_files();

  // repeated string vector_files = 4;
  int vector_files_size() const;
  void clear_vector_files();
  static const int kVectorFilesFieldNumber = 4;
  const ::std::string& vector_files(int index) const;
  ::std::string* mutable_vector_files(int index);
  void set_vector_files(int index, const ::std::string& value);
#if LANG_CXX11
  void set_vector_files(int index, ::std::string&& value);
#endif
  void set_vector_files(int index, const char* value);
  void set_vector_files(int index, const char* value, size_t size);
  ::std::string* add_vector_files();
  void add_vector_files(const ::std::string& value);
#if LANG_CXX11
  void add_vector_files(::std::string&& value);
#endif
  void add_vector_files(const char* value);
  void add_vector_files(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& vector_files() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_vector_files();

  // repeated string delete_files = 5;
  int delete_files_size() const;
  void clear_delete_files();
  static const int kDeleteFilesFieldNumber = 5;
  const ::std::string& delete_files(int index) const;
  ::std::string* mutable_delete_files(int index);
  void set_delete_files(int index, const ::std::string& value);
#if LANG_CXX11
  void set_delete_files(int index, ::std::string&& value);
#endif
  void set_delete_files(int index, const char* value);
  void set_delete_files(int index, const char* value, size_t size);
  ::std::string* add_delete_files();
  void add_delete_files(const ::std::string& value);
#if LANG_CXX11
  void add_delete_files(::std::string&& value);
#endif
  void add_delete_files(const char* value);
  void add_delete_files(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& delete_files() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_delete_files();

  // .manifest_proto.SpaceOptions options = 1;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 1;

  private:
  const ::manifest_proto::SpaceOptions& _internal_options() const;

  public:
  const ::manifest_proto::SpaceOptions& options() const;
  ::manifest_proto::SpaceOptions* release_options();
  ::manifest_proto::SpaceOptions* mutable_options();
  void set_allocated_options(::manifest_proto::SpaceOptions* options);

  // .schema_proto.Schema schema = 2;
  bool has_schema() const;
  void clear_schema();
  static const int kSchemaFieldNumber = 2;

  private:
  const ::schema_proto::Schema& _internal_schema() const;

  public:
  const ::schema_proto::Schema& schema() const;
  ::schema_proto::Schema* release_schema();
  ::schema_proto::Schema* mutable_schema();
  void set_allocated_schema(::schema_proto::Schema* schema);

  // @@protoc_insertion_point(class_scope:manifest_proto.Manifest)
  private:
  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> scalar_files_;
  ::google::protobuf::RepeatedPtrField<::std::string> vector_files_;
  ::google::protobuf::RepeatedPtrField<::std::string> delete_files_;
  ::manifest_proto::SpaceOptions* options_;
  ::schema_proto::Schema* schema_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_manifest_2eproto::TableStruct;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SpaceOptions

// string uri = 1;
inline void SpaceOptions::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpaceOptions::uri() const {
  // @@protoc_insertion_point(field_get:manifest_proto.SpaceOptions.uri)
  return uri_.GetNoArena();
}
inline void SpaceOptions::set_uri(const ::std::string& value) {
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:manifest_proto.SpaceOptions.uri)
}
#if LANG_CXX11
inline void SpaceOptions::set_uri(::std::string&& value) {
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:manifest_proto.SpaceOptions.uri)
}
#endif
inline void SpaceOptions::set_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);

  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:manifest_proto.SpaceOptions.uri)
}
inline void SpaceOptions::set_uri(const char* value, size_t size) {
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
                  ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:manifest_proto.SpaceOptions.uri)
}
inline ::std::string* SpaceOptions::mutable_uri() {
  // @@protoc_insertion_point(field_mutable:manifest_proto.SpaceOptions.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpaceOptions::release_uri() {
  // @@protoc_insertion_point(field_release:manifest_proto.SpaceOptions.uri)

  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpaceOptions::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
  } else {
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:manifest_proto.SpaceOptions.uri)
}

// -------------------------------------------------------------------

// Manifest

// .manifest_proto.SpaceOptions options = 1;
inline bool Manifest::has_options() const { return this != internal_default_instance() && options_ != NULL; }
inline void Manifest::clear_options() {
  if (GetArenaNoVirtual() == NULL && options_ != NULL) {
    delete options_;
  }
  options_ = NULL;
}
inline const ::manifest_proto::SpaceOptions& Manifest::_internal_options() const { return *options_; }
inline const ::manifest_proto::SpaceOptions& Manifest::options() const {
  const ::manifest_proto::SpaceOptions* p = options_;
  // @@protoc_insertion_point(field_get:manifest_proto.Manifest.options)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::manifest_proto::SpaceOptions*>(
                         &::manifest_proto::_SpaceOptions_default_instance_);
}
inline ::manifest_proto::SpaceOptions* Manifest::release_options() {
  // @@protoc_insertion_point(field_release:manifest_proto.Manifest.options)

  ::manifest_proto::SpaceOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::manifest_proto::SpaceOptions* Manifest::mutable_options() {
  if (options_ == NULL) {
    auto* p = CreateMaybeMessage<::manifest_proto::SpaceOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:manifest_proto.Manifest.options)
  return options_;
}
inline void Manifest::set_allocated_options(::manifest_proto::SpaceOptions* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(message_arena, options, submessage_arena);
    }

  } else {
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:manifest_proto.Manifest.options)
}

// .schema_proto.Schema schema = 2;
inline bool Manifest::has_schema() const { return this != internal_default_instance() && schema_ != NULL; }
inline const ::schema_proto::Schema& Manifest::_internal_schema() const { return *schema_; }
inline const ::schema_proto::Schema& Manifest::schema() const {
  const ::schema_proto::Schema* p = schema_;
  // @@protoc_insertion_point(field_get:manifest_proto.Manifest.schema)
  return p != NULL ? *p : *reinterpret_cast<const ::schema_proto::Schema*>(&::schema_proto::_Schema_default_instance_);
}
inline ::schema_proto::Schema* Manifest::release_schema() {
  // @@protoc_insertion_point(field_release:manifest_proto.Manifest.schema)

  ::schema_proto::Schema* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline ::schema_proto::Schema* Manifest::mutable_schema() {
  if (schema_ == NULL) {
    auto* p = CreateMaybeMessage<::schema_proto::Schema>(GetArenaNoVirtual());
    schema_ = p;
  }
  // @@protoc_insertion_point(field_mutable:manifest_proto.Manifest.schema)
  return schema_;
}
inline void Manifest::set_allocated_schema(::schema_proto::Schema* schema) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(schema_);
  }
  if (schema) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      schema = ::google::protobuf::internal::GetOwnedMessage(message_arena, schema, submessage_arena);
    }

  } else {
  }
  schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:manifest_proto.Manifest.schema)
}

// repeated string scalar_files = 3;
inline int Manifest::scalar_files_size() const { return scalar_files_.size(); }
inline void Manifest::clear_scalar_files() { scalar_files_.Clear(); }
inline const ::std::string& Manifest::scalar_files(int index) const {
  // @@protoc_insertion_point(field_get:manifest_proto.Manifest.scalar_files)
  return scalar_files_.Get(index);
}
inline ::std::string* Manifest::mutable_scalar_files(int index) {
  // @@protoc_insertion_point(field_mutable:manifest_proto.Manifest.scalar_files)
  return scalar_files_.Mutable(index);
}
inline void Manifest::set_scalar_files(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:manifest_proto.Manifest.scalar_files)
  scalar_files_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Manifest::set_scalar_files(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:manifest_proto.Manifest.scalar_files)
  scalar_files_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Manifest::set_scalar_files(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  scalar_files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:manifest_proto.Manifest.scalar_files)
}
inline void Manifest::set_scalar_files(int index, const char* value, size_t size) {
  scalar_files_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:manifest_proto.Manifest.scalar_files)
}
inline ::std::string* Manifest::add_scalar_files() {
  // @@protoc_insertion_point(field_add_mutable:manifest_proto.Manifest.scalar_files)
  return scalar_files_.Add();
}
inline void Manifest::add_scalar_files(const ::std::string& value) {
  scalar_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:manifest_proto.Manifest.scalar_files)
}
#if LANG_CXX11
inline void Manifest::add_scalar_files(::std::string&& value) {
  scalar_files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:manifest_proto.Manifest.scalar_files)
}
#endif
inline void Manifest::add_scalar_files(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  scalar_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:manifest_proto.Manifest.scalar_files)
}
inline void Manifest::add_scalar_files(const char* value, size_t size) {
  scalar_files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:manifest_proto.Manifest.scalar_files)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& Manifest::scalar_files() const {
  // @@protoc_insertion_point(field_list:manifest_proto.Manifest.scalar_files)
  return scalar_files_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* Manifest::mutable_scalar_files() {
  // @@protoc_insertion_point(field_mutable_list:manifest_proto.Manifest.scalar_files)
  return &scalar_files_;
}

// repeated string vector_files = 4;
inline int Manifest::vector_files_size() const { return vector_files_.size(); }
inline void Manifest::clear_vector_files() { vector_files_.Clear(); }
inline const ::std::string& Manifest::vector_files(int index) const {
  // @@protoc_insertion_point(field_get:manifest_proto.Manifest.vector_files)
  return vector_files_.Get(index);
}
inline ::std::string* Manifest::mutable_vector_files(int index) {
  // @@protoc_insertion_point(field_mutable:manifest_proto.Manifest.vector_files)
  return vector_files_.Mutable(index);
}
inline void Manifest::set_vector_files(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:manifest_proto.Manifest.vector_files)
  vector_files_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Manifest::set_vector_files(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:manifest_proto.Manifest.vector_files)
  vector_files_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Manifest::set_vector_files(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  vector_files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:manifest_proto.Manifest.vector_files)
}
inline void Manifest::set_vector_files(int index, const char* value, size_t size) {
  vector_files_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:manifest_proto.Manifest.vector_files)
}
inline ::std::string* Manifest::add_vector_files() {
  // @@protoc_insertion_point(field_add_mutable:manifest_proto.Manifest.vector_files)
  return vector_files_.Add();
}
inline void Manifest::add_vector_files(const ::std::string& value) {
  vector_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:manifest_proto.Manifest.vector_files)
}
#if LANG_CXX11
inline void Manifest::add_vector_files(::std::string&& value) {
  vector_files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:manifest_proto.Manifest.vector_files)
}
#endif
inline void Manifest::add_vector_files(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  vector_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:manifest_proto.Manifest.vector_files)
}
inline void Manifest::add_vector_files(const char* value, size_t size) {
  vector_files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:manifest_proto.Manifest.vector_files)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& Manifest::vector_files() const {
  // @@protoc_insertion_point(field_list:manifest_proto.Manifest.vector_files)
  return vector_files_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* Manifest::mutable_vector_files() {
  // @@protoc_insertion_point(field_mutable_list:manifest_proto.Manifest.vector_files)
  return &vector_files_;
}

// repeated string delete_files = 5;
inline int Manifest::delete_files_size() const { return delete_files_.size(); }
inline void Manifest::clear_delete_files() { delete_files_.Clear(); }
inline const ::std::string& Manifest::delete_files(int index) const {
  // @@protoc_insertion_point(field_get:manifest_proto.Manifest.delete_files)
  return delete_files_.Get(index);
}
inline ::std::string* Manifest::mutable_delete_files(int index) {
  // @@protoc_insertion_point(field_mutable:manifest_proto.Manifest.delete_files)
  return delete_files_.Mutable(index);
}
inline void Manifest::set_delete_files(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:manifest_proto.Manifest.delete_files)
  delete_files_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Manifest::set_delete_files(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:manifest_proto.Manifest.delete_files)
  delete_files_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Manifest::set_delete_files(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  delete_files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:manifest_proto.Manifest.delete_files)
}
inline void Manifest::set_delete_files(int index, const char* value, size_t size) {
  delete_files_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:manifest_proto.Manifest.delete_files)
}
inline ::std::string* Manifest::add_delete_files() {
  // @@protoc_insertion_point(field_add_mutable:manifest_proto.Manifest.delete_files)
  return delete_files_.Add();
}
inline void Manifest::add_delete_files(const ::std::string& value) {
  delete_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:manifest_proto.Manifest.delete_files)
}
#if LANG_CXX11
inline void Manifest::add_delete_files(::std::string&& value) {
  delete_files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:manifest_proto.Manifest.delete_files)
}
#endif
inline void Manifest::add_delete_files(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  delete_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:manifest_proto.Manifest.delete_files)
}
inline void Manifest::add_delete_files(const char* value, size_t size) {
  delete_files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:manifest_proto.Manifest.delete_files)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& Manifest::delete_files() const {
  // @@protoc_insertion_point(field_list:manifest_proto.Manifest.delete_files)
  return delete_files_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* Manifest::mutable_delete_files() {
  // @@protoc_insertion_point(field_mutable_list:manifest_proto.Manifest.delete_files)
  return &delete_files_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

}  // namespace manifest_proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_manifest_2eproto
